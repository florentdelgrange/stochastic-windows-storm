// randomized dining philosophers [LR81]
// dxp/gxn 23/01/02

// model which does not require fairness
// remove the possibility of loops:
// (1) cannot stay in thinking 
// (2) if first fork not free then cannot move (another philosopher must more)

mdp

// atomic formulae 
// left fork free and right fork free resp.
formula lfree = (p2>=0&p2<=4)|p2=6|p2=10;
formula rfree = (p3>=0&p3<=3)|p3=5|p3=7|p3=11;

formula is_eating = ((p1>=8)&(p1<=9))|((p2>=8)&(p2<=9))|((p3>=8)&(p3<=9));
formula is_hungry = ((p1>0)&(p1<8))|((p2>0)&(p2<8))|((p3>0)&(p3<8));
formula thinking = p1=0|p2=0|p3=0;

module phil1

	p1: [0..11];

	[try_p1] p1=0 -> (p1'=1); // trying
	[try_p1] p1=1 -> 0.5 : (p1'=2) + 0.5 : (p1'=3); // draw randomly
	[try_p1] p1=2 &  lfree -> (p1'=4); // pick up left
	[try_p1] p1=3 &  rfree -> (p1'=5); // pick up right
	[try_p1] p1=4 &  rfree -> (p1'=8); // pick up right (got left)
	[try_p1] p1=4 & !rfree -> (p1'=6); // right not free (got left)
	[try_p1] p1=5 &  lfree -> (p1'=8); // pick up left (got right)
	[try_p1] p1=5 & !lfree -> (p1'=7); // left not free (got right)
	[try_p1] p1=6  -> (p1'=1); // put down left
	[try_p1] p1=7  -> (p1'=1); // put down right
	[eat_p1] p1=8  -> (p1'=9); // move to eating (got forks)
	[] p1=9  -> (p1'=10); // finished eating and put down left 
	[] p1=9  -> (p1'=11); // finished eating and put down right
	[] p1=10 -> (p1'=0); // put down right and return to think
	[] p1=11 -> (p1'=0); // put down left and return to think

endmodule

// construct further modules through renaming
module phil2 = phil1 [ p1=p2, p2=p3, p3=p1, try_p1=try_p2, eat_p1=eat_p2 ] endmodule
module phil3 = phil1 [ p1=p3, p2=p1, p3=p2, try_p1=try_p3, eat_p1=eat_p3 ] endmodule

// labels
label "hungry" = ((p1>0)&(p1<8))|((p2>0)&(p2<8))|((p3>0)&(p3<8));
label "eat" = ((p1>=8)&(p1<=9))|((p2>=8)&(p2<=9))|((p3>=8)&(p3<=9));

// liveness property (if a philosopher is hungry then eventually some philosopher eats)
// filter(forall, "hungry" => P>=1 [ F "eat"])
// with time bound lambda = 5
// Pmax=? [DFW{"priorities"}(5)], Pmax=? [FW{"priorities"}(5)], Pmax=? [BW{"priorities"}]

rewards "priorities"
 is_hungry & !is_eating : 1;
 is_eating : 0;
 !is_hungry & !is_eating : 2;
endrewards

// Pmax=? [DFW{"weights"}(5)], Pmax=? [FW{"weights"}(5)], Pmax=? [BW{"weights"}]
const int lambda = 5; // window size
rewards "weights"
 [try_p1] true : -1;
 [try_p2] true : -1;
 [try_p3] true : -1;
 [eat_p1] true : lambda -1;
 [eat_p2] true : lambda -1;
 [eat_p3] true : lambda -1;
endrewards
